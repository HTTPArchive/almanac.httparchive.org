name: Progress Tracker

env:
  # Update these environment variables every year
  FILTER_LABEL: '2020 chapter'
  TRACKER_ISSUE_NUMBER: 989
  TOTAL_TRACKED_TASKS: 10
  SQL_BASE_DIR: 'https://github.com/HTTPArchive/almanac.httparchive.org/tree/main/sql/2020/'

on:
  workflow_dispatch:
  issues:
    types:
      - edited

jobs:
  track-progress:
    name: Track Progress
    if: github.repository == 'HTTPArchive/almanac.httparchive.org'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v2
        if: github.event_name == 'workflow_dispatch' || contains(github.event.issue.labels.*.name, env.FILTER_LABEL)
        with:
          script: |
            const filterLabel = process.env.FILTER_LABEL
            const trackerIssueNumber = process.env.TRACKER_ISSUE_NUMBER
            const totalTrackedTasks = parseInt(process.env.TOTAL_TRACKED_TASKS, 10)
            const sqlBaseDir = process.env.SQL_BASE_DIR

            const icons = {
              draft: 'üìÑ',
              sql: 'üîç',
              results: 'üìä'
            }

            const linkMap = {
              draft: /^\[~draft-doc\]:\s*(?<link>\S+)/,
              sql: /^\[~sql-dir\]:\s*(?<link>\S+)/,
              results: /^\[~results-sheet\]:\s*(?<link>\S+)/
            }

            const parseTasks = text => {
              const tasks = []
              text.split('\n').forEach(line => {
                if (/^(\s{2,})?([*+-]|\d+\.)\s+\[ \]\s+\S+/.test(line)) {
                  tasks.push('')
                }
                if (/^(\s{2,})?([*+-]|\d+\.)\s+\[[xX]\]\s+\S+/.test(line)) {
                  tasks.push('‚òë')
                }
              })
              return tasks
            }

            const parseLinks = text => {
              const links = {}
              text.split('\n').forEach(line => {
                for (const [k, v] of Object.entries(linkMap)) {
                  const m = line.match(v)
                  if (m) {
                    links[k] = m.groups.link
                  }
                }
              })
              return links
            }

            const parseHeading = text => {
              const m = text.match(/^#\s+Part\s+(?<part>\S+)\s+Chapter\s+(?<number>\S+)\s*:\s*(?<title>.+)/)
              return m ? m.groups : {part: '', number: '', title: ''}
            }

            const parseUserNames = members => {
              return [...members.matchAll(/@(?<username>\w+)/g)].map(u => u.groups.username)
            }

            const parseTeam = text => {
              const team = {}
              text.split('\n').forEach(line => {
                if (/\|\s*\[Sheet\]\[~results-sheet\]\s*\|/.test(line)) {
                  const [, authors, reviewers, analysts] = line.split('|')
                  team.Authors = parseUserNames(authors)
                  team.Reviewers = parseUserNames(reviewers)
                  team.Analysts = parseUserNames(analysts)
                }
              })
              return team
            }

            const formatLinks = links => {
              return Object.entries(links).filter(l => !['#', sqlBaseDir].includes(l[1])).map(l => `[${icons[l[0]] || l[0]}](${l[1]})`).join(' ')
            }

            const formatTeam = team => {
              return Object.entries(team).map(([k, v]) => `<span title="${k}: ${v.length ? v.join(', ') : 'TBD'}">${v.length}</span>`).join('/')
            }

            const formatRow = chapter => {
              return `${chapter.number ? `<span title="Part: ${chapter.part}, Chapter: ${chapter.number}">${chapter.number}</span> - ` : ''}[${chapter.title}](${chapter.url}) | ${formatLinks(chapter.links)} | ${formatTeam(chapter.team)} | ${chapter.tasks.join(' | ')}`
            }

            const taskIssues = await github.paginate(github.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              direction: 'asc',
              labels: filterLabel
            })

            let chapters = []
            for (const issue of taskIssues) {
              const tasksStatus = parseTasks(issue.body)
              const tasksCount = tasksStatus.length
              if(tasksCount != totalTrackedTasks) {
                core.info(`Skipping issue #${issue.number} with ${tasksCount} instead of ${totalTrackedTasks} tasks`)
                continue
              }
              core.info(`Adding issue #${issue.number} with ${tasksCount} tasks`)
              const heading = parseHeading(issue.body)
              chapters.push({
                id: issue.number,
                url: issue.html_url,
                title: heading.title || issue.title,
                part: heading.part,
                number: heading.number,
                links: parseLinks(issue.body),
                team: parseTeam(issue.body),
                tasks: tasksStatus
              })
            }

            if(!chapters.length) {
              core.info(`Nothing to report`)
              return
            }

            chapters.sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}))

            const report = [
              `Chapters | Links | Team | ${Array(totalTrackedTasks).fill().map((v, i) => i + 1).join(' | ')}`,
              `:--------|:------|:----:${'|:-:'.repeat(totalTrackedTasks)}`
            ].concat(chapters.map(formatRow)).join('\n')

            const progressIssue = await github.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: trackerIssueNumber
            })

            github.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: trackerIssueNumber,
              body: progressIssue.data.body.replace(/<!-- REPORT START -->[\s\S]*<!-- REPORT END -->/, `<!-- REPORT START -->\n${report}<!-- REPORT END -->`)
            })

            core.info(`Updated report in issue #${trackerIssueNumber} with ${chapters.length} chapters`)
