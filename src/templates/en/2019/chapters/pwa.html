{% extends "en/2019/base_chapter.html" %}

<!--{# IMPORTANT!

- `chapter.html` is a "template for templates" used by the `generate_chapters.js` script, hence the strange template syntax (eg, mixing ejs and jinja syntax)
- if you want to modify `chapter.html`, you must also:
  - translate the corresponding language-specific templates (eg `src/templates/<lang>/<year>/chapter.html`)
  - run the generation script to update each chapter template
- if you want to modify the chapter templates (eg `src/templates/<lang>/<year>/chapters/<chapter>.html`):
  - make changes to the markdown content directly (`src/content/<lang>/<year>/<chapter>.md`) because any changes to the chapter templates will be overwritten by the generation script
#}-->

{% set metadata = {"part_number":"II","chapter_number":11,"title":"PWA","authors":["tomayac","jeffposnick"],"reviewers":["hyperpress","ahmadawais"]} %} {% block main %}
<article id="chapter" class="main">
  <nav class="index">
    <div class="index-box floating-card">
      <h2 class="header">Index</h2>
      <ul>
        <li>
          <a href="#introduction">Introduction</a>
        </li>

        <li>
          <a href="#service-workers">Service Workers</a>

          <ul>
            <li>
              <a href="#service-worker-registrations-and-installability">Service Worker Registrations and Installability</a>
            </li>

            <li>
              <a href="#service-worker-events">Service Worker Events</a>
            </li>

            <li>
              <a href="#service-worker-file-sizes">Service Worker File Sizes</a>
            </li>
          </ul>
        </li>

        <li>
          <a href="#web-app-manifests">Web App Manifests</a>

          <ul>
            <li>
              <a href="#web-app-manifest-properties">Web App Manifest Properties</a>
            </li>

            <li>
              <a href="#display-values">Display Values</a>
            </li>

            <li>
              <a href="#category-values">Category Values</a>
            </li>

            <li>
              <a href="#icon-sizes">Icon Sizes</a>
            </li>

            <li>
              <a href="#orientation-values">Orientation Values</a>
            </li>
          </ul>
        </li>

        <li>
          <a href="#workbox">Workbox</a>
        </li>

        <li>
          <a href="#conclusion">Conclusion</a>
        </li>
      </ul>
    </div>
  </nav>

  <section class="content">
    <section class="body">
      <h1 class="title">
        <div class="subtitle">Part {{ metadata.get('part_number') }} Chapter {{ metadata.get('chapter_number') }}</div>
        {{ metadata.get('title') }}
      </h1>
      <img src="/static/images/2019/{{ get_chapter_image_dir(metadata) }}/hero_lg.jpg" class="content-banner" />
      {{ render_byline() }}
      <h2 id="introduction">Introduction</h2>
      <p>
        Progressive Web Apps (PWA) are a new class of web applications, building on top of platform primitives <br />
        like the <a href="https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API">Service Worker APIs</a>. <br />
        Service workers allow apps to support network-independent loading by acting as a network proxy, <br />
        intercepting your web app's outgoing requests, and replying with programmatic or cached responses. <br />
        Service workers can receive push notifications and synchronize data in the background even when<br />
        the corresponding app is not running. Additional, service workers — together with <br />
        <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web App Manifests</a> — <br />
        allow users to install PWAs to their devices’ home screens.
      </p>
      <p>
        Service workers were <a href="https://blog.chromium.org/2014/12/chrome-40-beta-powerful-offline-and.html">first implemented in Chrome 40</a>, <br />
        back in December 2014, and the term Progressive Web Apps was <br />
        <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/">coined by Frances Berriman and Alex Russell</a> <br />
        in 2015. As service workers are now finally <a href="https://jakearchibald.github.io/isserviceworkerready/">implemented in all major browsers</a>, <br />
        we were wondering how many PWAs are actually out there, and how do they make use of these new technologies? <br />
        Certain advanced APIs like <a href="https://developers.google.com/web/updates/2015/12/background-sync">Background Sync</a> <br />
        are currently still <a href="https://caniuse.com/#feat=background-sync">only available on Chromium-based browsers</a>, <br />
        so as an additional question, we looked into which features these PWAs actually use.
      </p>
      <h2 id="service-workers">Service Workers</h2>
      <h3 id="service-worker-registrations-and-installability">Service Worker Registrations and Installability</h3>
      <p>
        The first metric we explore are service worker installations. Looking at the data exposed through <br />
        feature counters in the HTTP Archive, we find that 0.44% of all desktop and 0.37% of all mobile pages <br />
        register a service worker, and both curves over time are steeply growing. Now this might not look overly <br />
        impressive, but taking traffic data from Chrome Platform Status into account, we can see that about <br />
        <a href="https://www.chromestatus.com/metrics/feature/timeline/popularity/990">a service worker controlled 15% of all page loads</a>,<br />
        which can be interpreted as popular, high-traffic sites increasingly having started to embrace service workers.
      </p>
      <p><code>&lt;timeseries chart of 11_01b&gt;</code></p>
      <p><strong>Figure 1:</strong> Service Worker installation over time for desktop and mobile</p>
      <p>
        Lighthouse checks whether a page is eligble for an <a href="https://developers.google.com/web/tools/lighthouse/audits/install-prompt">install prompt</a><br />
        though it currently is only available for mobile pages. Looking at Lighthouse data in the HTTP Archive, 1.56% of mobile pages have an<br />
        <a href="https://web.dev/installable-manifest/">installable manifest</a>. Readers may notice this is higher than the 0.37% of mobile pages that<br />
        register a service worker, which is also a requirement of the install prompt<br />
        (<a href="https://github.com/GoogleChrome/web.dev/issues/1797">issue raised to make this clearer in the documentation</a>).<br />
        The difference in these numbers may be due to Service Workers being registered on pages other than the home page as the <a href="./methodology">Web Almanac only is restricted just to home pages</a>.
      </p>
      <p>
        To control the install experience, 0.82% of all desktop and 0.94% of all mobile pages use the <a href="https://w3c.github.io/manifest/#beforeinstallpromptevent-interface"><code>OnBeforeInstallPrompt</code> interface</a>. At present <a href="https://caniuse.com/#feat=web-app-manifest">support is limited to Chromium based browsers</a>.
      </p>
      <h3 id="service-worker-events">Service Worker Events</h3>
      <p>In a service worker one can <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">listen for a number of events</a>:</p>
      <ul>
        <li><code>install</code> - which occurs upon service worker installation.</li>
        <li><code>activate</code> - which occurs upon service worker activation.</li>
        <li><code>fetch</code> - which occurs whenever a resource is fetched.</li>
        <li><code>push</code> - which occurs when a push notification arrives.</li>
        <li><code>notificationclick</code> - which occurs when a notification is being clicked.</li>
        <li><code>notificationclose</code> - which occurs when a notification is being closed.</li>
        <li><code>message</code> - which occurs when a message sent via <code>postMessage()</code> arrives.</li>
        <li><code>sync</code> - which occurs when a Background Sync event occurs.</li>
      </ul>
      <p>
        We have examined which of these events are being listened to by service workers we could find in the HTTP Archive. <br />
        The results for mobile and desktop are very similar with <code>fetch</code>, <code>install</code>, and <code>activate</code> being the three <br />
        most popular events, followed by <code>notificationclick</code> and <code>push</code>. If we interpret these results, offline use <br />
        cases that service workers enable are the most attractive feature for app developers, far ahead of <br />
        push notifications. Due to its limited availability, and less common use case, background sync doesn’t <br />
        play a significant role at the moment.
      </p>
      <p><code>&lt;bar chart of 11_03 mobile&gt;</code></p>
      <p><strong>Figure 2a:</strong> Service worker events on mobile, ordered by decreasing frequency.</p>
      <p><code>&lt;bar chart of 11_03 desktop&gt;</code></p>
      <p><strong>Figure 2b:</strong> Service worker events on desktop, ordered by decreasing frequency.</p>
      <h3 id="service-worker-file-sizes">Service Worker File Sizes</h3>
      <p>
        File size or lines of code are in general a bad proxy for the complexity of the task at hand. <br />
        In this case, however, it is definitely interesting to compare (compressed) file sizes of service workers <br />
        for mobile and desktop. The median service worker file on desktop is 895 bytes, whereas on mobile it’s 694 bytes. <br />
        Throughout all percentiles desktop service workers are larger than mobile service workers. <br />
        We note that these stats don’t account for dynamically imported scripts through the <br />
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts"><code>importScripts()</code></a> method, <br />
        which likely skews the results higher.
      </p>
      <p><code>&lt;distribution of 11_03b mobile&gt;</code></p>
      <p><strong>Figure 3a:</strong> Percentiles of service worker file sizes on mobile.</p>
      <p><code>&lt;distribution of 11_03b desktop&gt;</code></p>
      <p><strong>Figure 3b:</strong> Percentiles of service worker file sizes on desktop.</p>
      <h2 id="web-app-manifests">Web App Manifests</h2>
      <h3 id="web-app-manifest-properties">Web App Manifest Properties</h3>
      <p>
        The web app manifest is a simple JSON file that tells the browser about a web application <br />
        and how it should behave when installed on the user's mobile device or desktop. A typical <br />
        manifest file includes information about the app name, icons it should use, the start URL <br />
        it should open at when launched, and more. Only 1.54% of all encountered manifests were <br />
        invalid JSON, and the rest parsed correctly.
      </p>
      <p>
        We looked at the different properties defined by the <br />
        <a href="https://w3c.github.io/manifest/#webappmanifest-dictionary">specification</a>, <br />
        and also considered non-standard proprietary properties. According to the Web App Manifest spec, <br />
        the following properties are allowed: <code>dir</code>, <code>lang</code>, <code>name</code>, <code>short_name</code>, <code>description</code>, <br />
        <code>icons</code>, <code>screenshots</code>, <code>categories</code>, <code>iarc_rating_id</code>, <code>start_url</code>, <code>display</code>, <code>orientation</code>, <br />
        <code>theme_color</code>, <code>background_color</code>, <code>scope</code>, <code>serviceworker</code>, <code>related_applications</code>, and <br />
        <code>prefer_related_applications</code>. The only property that we didn’t observe in the wild was <br />
        <code>iarc_rating_id</code>, which is a string that represents the International Age Rating Coalition (IARC) <br />
        certification code of the web application. It is intended to be used to determine which ages <br />
        the web application is appropriate for. The proprietary properties we encountered still <br />
        frequently were <code>gcm_sender_id</code> and <code>gcm_user_visible_only</code> from the legacy <br />
        Google Cloud Messaging (GCM) service. Interestingly there’re almost no differences between mobile <br />
        and desktop. On both platforms, however, there’s a long tail of properties that are not interpreted <br />
        by browsers but that contain potentially useful metadata like <code>author</code> or <code>version</code>. We also found <br />
        a non-trivial amount of mistyped properties; our favorite being <code>shot_name</code>. An interesting outlier<br />
        is the <code>serviceworker</code> property, which is standard but not implemented by any browser vendor —<br />
        nevertheless, it was found on 0.09% of all web app manifests used by mobile and desktop pages.
      </p>
      <p><code>&lt;bar chart of 11_04 mobile&gt;</code></p>
      <p><strong>Figure 4a:</strong> Web App Manifest properties ordered by decreasing popularity on mobile.</p>
      <p><code>&lt;bar chart of 11_04 mobile&gt;</code></p>
      <p><strong>Figure 4b:</strong> Web App Manifest properties ordered by decreasing popularity on desktop.</p>
      <h3 id="display-values">Display Values</h3>
      <p>
        Looking at the values developers set for the <code>display</code> property, it becomes immediately clear <br />
        that they want PWAs to be perceived as “proper” apps that don’t reveal their web technology origins.<br />
        By choosing <code>"standalone"</code>, they make sure no browser UI is shown to the end-user. This is reflected <br />
        by the majority of apps that make use of the <code>prefers_related_applications</code> property: more that 97% <br />
        of both mobile and desktop applications do <em>not</em> prefer native applications.
      </p>
      <p><code>&lt;11_04c mobile&gt;</code></p>
      <p><strong>Figure 5a:</strong> Values for the <code>display</code> property on mobile.</p>
      <p><code>&lt;11_04c desktop&gt;</code></p>
      <p><strong>Figure 5b:</strong> Values for the <code>display</code> property on desktop.</p>
      <h3 id="category-values">Category Values</h3>
      <p>
        The <code>categories</code> member describes the expected application categories to which the web application belongs. <br />
        It is only meant as a hint to catalogs or app stores listing web applications, and it is expected that<br />
        these will make a best effort to find appropriate categories (or category) under which to list the <br />
        web application. There were not too many manifests that made use of the property, but it is <br />
        interesting to see the shift from <em>shopping</em> being the most popular category on mobile to <em>business</em>, <br />
        <em>technology</em>, and <em>web</em> (whatever may be meant with that) on desktop that share the first place evenly.
      </p>
      <p><code>&lt;11_04d mobile&gt;</code></p>
      <p><strong>Figure 6a:</strong> Values for the <code>categories</code> property on mobile.</p>
      <p><code>&lt;11_04d desktop&gt;</code></p>
      <p><strong>Figure 6b:</strong> Values for the <code>categories</code> property on desktop.</p>
      <h3 id="icon-sizes">Icon Sizes</h3>
      <p>
        Lighthouse <a href="https://developers.google.com/web/tools/lighthouse/audits/manifest-contains-192px-icon">requires</a> <br />
        at least an icon sized 192×192, but common favicon generation tools create a plethora of other sizes, too. <br />
        Lighthouse’s rule is probably the culprit for 192×192 being the most popular choice of icon size on both <br />
        desktop and mobile, despite <a href="https://developers.google.com/web/fundamentals/web-app-manifest#icons">Google’s documentation</a> <br />
        additionally explicitly recommending 512×512, which doesn’t show as a particularly prominent option.
      </p>
      <p><code>&lt;11_04f mobile&gt;</code></p>
      <p><strong>Figure 7a:</strong> Popular icon sizes on mobile.</p>
      <p><code>&lt;11_04f desktop&gt;</code></p>
      <p><strong>Figure 7b:</strong> Popular icon sizes on desktop.</p>
      <h3 id="orientation-values">Orientation Values</h3>
      <p>
        The valid values for the <code>orientation</code> property are<br />
        <a href="https://www.w3.org/TR/screen-orientation/#dom-orientationlocktype">defined in the Screen Orientation API specification</a>.<br />
        Namely there are <code>"any"</code>, <code>"natural"</code>, <code>"landscape"</code>, <code>"portrait"</code>, <code>"portrait-primary"</code>, <code>"portrait-secondary"</code>,<br />
        <code>"landscape-primary"</code>, and <code>"landscape-secondary"</code>.<br />
        Portrait orientation is the clear winner on both platforms, followed by any orientation.
      </p>
      <p><code>&lt;11_04g mobile&gt;</code></p>
      <p><strong>Figure 8a:</strong> Popular orientation values on mobile.</p>
      <p><code>&lt;11_04g desktop&gt;</code></p>
      <p><strong>Figure 8b:</strong> Popular orientation values on desktop.</p>
      <h2 id="workbox">Workbox</h2>
      <p>
        <a href="https://developers.google.com/web/tools/workbox">Workbox</a> is a set of libraries that help with common service worker<br />
        use cases. For instance, Workbox has tools that can plug in to your build process and generate a manifest of files,<br />
        which are then precached by your service worker. Workbox includes libraries to handle runtime caching, request routing,<br />
        cache expiration, background sync, and more.
      </p>
      <p>
        Given the low-level nature of the service worker APIs, many developers have turned to Workbox as a way of <br />
        structuring their service worker logic into higher-level, reusable chunks of code. Workbox adoption is also <br />
        driven by its inclusion as a feature in a number of popular JavaScript framework starter kits, like <br />
        <a href="https://create-react-app.dev/"><code>create-react-app</code></a> and <a href="https://www.npmjs.com/package/@vue/cli-plugin-pwa">Vue's PWA plugin</a>.
      </p>
      <p>
        The HTTP Archive shows that, out of the total population of sites that register a service worker, <br />
        12.71% of them are using at least one of the Workbox libraries. This percentage is roughly consistent <br />
        across desktop and mobile, with a slightly lower percentage (11.46%) on mobile compared to desktop (14.36%).
      </p>
      <h2 id="conclusion">Conclusion</h2>
      <p>
        The stats in this chapter show that PWAs are still only used by a small percentage of sites. However this relatively small usage<br />
        is driven by the more popular sites which have a much larger share of traffic, and pages beyond the home page may use this more:<br />
        we showed that 15% of page loads use a service workers. The advantages they give for <a href="./performance">performance</a> and<br />
        greater control over <a href="./caching">caching</a> particularly for <a href="./mobile">mobile</a>.
      </p>
      <p>
        PWAs have often been seen as Chrome-driven technology. Other browsers have made great strides recently to implement most of the<br />
        underlying technologies, although first-class installability lags on some platforms. it's positive to see support becoming more<br />
        widespread. <a href="https://twitter.com/firt">Maximiliano Firtman</a> does a great job of tracking this, including<br />
        <a href="https://medium.com/@firt/iphone-11-ipados-and-ios-13-for-pwas-and-web-development-5d5d9071cc49">explaining Safari PWA support</a>.<br />
        Apple doesn't use the term PWA much, and has<br />
        <a href="https://developer.apple.com/news/?id=09062019b">explicitly stated that these HTML5 apps are best delivered outside of the App Store</a>.<br />
        Microsoft went the opposite direction not only <a href="https://docs.microsoft.com/en-us/microsoft-edge/progressive-web-apps/microsoft-store">encouraging PWAs in it's app store, but even automatically indexing any found when as it craweled the web</a>, though with it<br />
        moving on from the Windows Phone platform the future of that is uncertain. Google has also<br />
        <a href="https://medium.com/@firt/google-play-store-now-open-for-progressive-web-apps-ec6f3c6ff3cc">made moves to accepting PWAs in its app store</a>.
      </p>
      <p>
        PWAs provide a path forward for developers who would prefer to build and release on the web instead of on native platforms and app stores.<br />
        Not every operating system and browser offers full parity with native software, but improvements continue, and perhaps 2020 is the year<br />
        where we see an explosion in deployments?
      </p>
    </section>
    <section class="authors">
      <h4>Authors</h4>
      {{ render_authors() }}
    </section>

    <nav id="chapter-navigation">
      {{ render_prevnext() }}
    </nav>
  </section>
</article>

{% endblock %}
